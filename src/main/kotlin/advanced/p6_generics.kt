package advanced

import java.util.*


fun <T> List<T>.firstHalf(): List<T>{
    return subList(0,size / 2)
}

val alphabet = ('A'..'Z').toList().firstHalf()
/*
       - Type param declaration
       - Generic receiver Type
       - Return Type
*/

//                              generic extension property
val <T> List<T>.median: T?
    get() =  subList(0,size / 2).firstOrNull()


//                              generic classes / interfaces

interface Comparable<T> {
    fun compareTo(other: T): Int
}

class Box : Comparable<Box> {
    override fun compareTo(other: Box): Int = TODO()
}

// nothing special yet, just like java

fun <T: Number> List<T>.head(): T = first()
// upper bound ( T must inherit Number )

fun <T> appendComma(arg: T): Appendable? where T :  CharSequence, T : Appendable {
    return arg.append(',')
}

/*
                       - where T :  CharSequence, T   ==> list of type param constrains
                       - the 'Appendable' in the end, is the upper bound
                       - Appendable? is the return type of the method

                       if you ever find yourself using this syntax, you probably over-engineer
*/



//          nullability and generics

fun  <T> printHashCode(t: T) = println(t?.hashCode()) // 'Any?' upper  bound ( t can be null )
fun  <T: Any> printHashCode1(t: T) = println(t.hashCode()) //  'Any' upper bound. ( t != null )



//                  REIFIED TYPES


val list1: List<String> = listOf("a", "b")
val list2: List<Int> = listOf(1, 2, 3)

/*
                list1 and list2 are the same in runtime
                the compiler erases the Generic Types and only List remains
                List without a type arg is called a JAVA RAW TYPE
*/

class Ninja<T> {
    fun identifyArg(arg: Collection<T>) {
//        if (arg is List<Int>){
//            println(arg)
//        }
// todo: the above wont compile - uncomment the code and hover over List<Int> in IDEA
        if (arg.first() is List<*>) { //            star projection syntax
            println("its a list of lists of something!")
        }
    }
}


/*
            fun <T> isA(value: Any) = value is T
    this wont compile because the type of T is erased at runtime


    what can we do ?
    inline functions to the rescue !!!

 */


inline fun <reified T> isA(value: Any) = value is T

/*
    this works because the compiler inlines the generated bytecode and does not
    erase the type information

    this feature is very handy when using dependency injection
*/


inline fun <reified T: Any> getInstanceOf(clazz: T) {
    ServiceLoader.load(clazz::class.java)
}
//          reified is very useful in real life


